## 소수 찾기

### 풀이
- map {숫자, 해당 숫자가 소수로 이미 판명되었는지 유무}
```c++
map<int, bool> num; 
```

- next_permutation 을 이용해 순열 구함
```c++
reverse(numbers.begin() + m, numbers.end());
```
- [reverse 참고](https://ansohxxn.github.io/algorithm/permutation/)
  - next_permutation이 {1, 2, 3, 4, 5}의 5P5 전체 순열의 다음 순열을 구한다.
  - 따라서 reverse 해주지 않는다면 r = 2 까지만 출력한다 하더라도 r = 2 부분까지를 prefix로 한 순열들이 뒤를 잇기 때문에 r = 2 부분까지가 중복해서 출력되게 된다. 
  - 예를 들어 reverse 해주어 r 부분 뒤를 전부 거꾸로 뒤집어 주지 않는다면 12345 👉 12354 이런 순서로 순열이 가기 때문에 인덱스 2까지만 출력해도 12가 6 번(3P3)은 중복되게 된다. (12로 시작하는 {3, 4, 5}의 모든 순열) 
  - 따라서 r 인덱스 뒷부분을 전부 뒤집어주어 `12345` 👉 `12354`로 다음 순열이 가는게 아닌, 바로 `12` 👉 `13`이 될 수 있도록 `12`로 시작하는 {3, 4, 5}의 모든 순열의 마지막 순열인 `12543`으로 만들어 주어야 한다. 바로 다음에 13으로 시작하는 순열이 될 수 있도록!